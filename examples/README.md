# Notes on the examples, and working with LeapMotionP5 #A typical Leap app works like this:Instantiate a `Listener` class, and pass that instance to the constructor of a `Controller` instance:    YourListener listener = new YourListener();    Controller controller = new Controller(listener);For each frame of data generated by the Leap, the `onFrame` method of the  `Listener` subclass instance is called, with the controller instance passed in.From that controller instance the listener can get the current frame (and from that frame get things like hands, fingers, gestures, etc. that have been detected.      void onFrame(Controller controller) {      Frame frame = controller.frame();      HandList hands = frame.hands();      // more code ....    }So, in order to have custom code you need to write your own `Listener` class that extends `com.leapmotion.leap.Listener`.You then jazzy-up `onFrame()` to handle what has been detected.Where it gets tricky is when you want your custom `Listener` to interact with the Processing environment.You have some choices.  One is to create custom properties or methods on your `Listener` that will report whatever useful data you select.  Then, in `draw()`  (in your main sketch code) you query the `Listener` instance for these details.The nice thing about this is that you `Listener` class is not coupled to the main  `PApplet` of your sketch.Another approach is to give your Listener a reference to the main PApplet instance.For example    // Assumes you have already defined a private "PApplet owner" someplace     void setOwner(PApplet ownerPapplet) {      owner = ownerPapplet;    }Then your `Listener` code can use this reference to do the rendering.This approach can get very tricky.  If you are going to use the reference to the owning sketch in order to render things then You need to understand how to work with Processing graphics here.   You also run the risk of writing horribly tangled code, because the main sketch is referencing the `Listener`, while the `Listener` is referencing the main sketch.If you want to initiate other behavior, such as sending OSC or MIDI, then having the `Listener` code do that directly is less messy.## The Examples ##`PointerLocation` is  looks for one or more `Pointables`, takes the average of their tip locations, and renders some data to the screen.  When you are writing a Leap program you need to decide how the 3D data maps to the 2D screen.  In particular you need to figure out what field-of-view to work with.  In other words, picture an imaginary box in front of the screen.  This is the area that will map to the 2D screen coordinates.  Any hand or fingers detected outside of that box can either be ignored or mapped to the edges the screen.  The size of this imaginary box determines how far a user needs to move their hands and fingers.